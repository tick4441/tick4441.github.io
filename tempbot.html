<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>bbtt</title>
<style>
  body {
    background: #121212;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0; padding: 0;
    display: flex; flex-direction: column; height: 100vh;
  }
  header {
    background: #1f1f1f;
    padding: 12px 20px;
    font-size: 1.5rem;
    font-weight: bold;
    color: #4caf50;
    text-align: center;
    user-select: none;
    border-bottom: 2px solid #4caf50;
  }
  #chat-window {
    flex: 1;
    padding: 15px 20px;
    overflow-y: auto;
    background: #222;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .message {
    max-width: 75%;
    padding: 10px 15px;
    border-radius: 15px;
    line-height: 1.3;
    font-size: 1rem;
    word-break: break-word;
  }
  .user-message {
    background: #4caf50;
    align-self: flex-end;
    color: #121212;
    border-bottom-right-radius: 2px;
  }
  .bot-message {
    background: #333;
    align-self: flex-start;
    color: #ddd;
    border-bottom-left-radius: 2px;
    font-family: 'Courier New', Courier, monospace;
  }
  .username {
    font-weight: 700;
    font-size: 0.85rem;
    margin-bottom: 3px;
    user-select: none;
  }
  .user-name {
    color: #a5d6a7;
    text-align: right;
  }
  .bot-name {
    color: #81c784;
    text-align: left;
  }
  #input-area {
    display: flex;
    padding: 15px 20px;
    background: #1f1f1f;
    border-top: 2px solid #4caf50;
  }
  #user-input {
    flex: 1;
    font-size: 1rem;
    padding: 10px 15px;
    border-radius: 20px;
    border: none;
    outline: none;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #333;
    color: #eee;
  }
  #send-btn {
    margin-left: 15px;
    background: #4caf50;
    border: none;
    color: #121212;
    font-weight: 700;
    font-size: 1rem;
    padding: 10px 18px;
    border-radius: 20px;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  #send-btn:hover {
    background: #66bb6a;
  }
  #send-btn:active {
    background: #388e3c;
  }
  /* Scrollbar */
  #chat-window::-webkit-scrollbar {
    width: 8px;
  }
  #chat-window::-webkit-scrollbar-thumb {
    background: #4caf50;
    border-radius: 4px;
  }
</style>
</head>
<body>
<header>bbtt</header>
<div id="chat-window"></div>
<div id="input-area">
  <input type="text" id="user-input" placeholder="Type your message here..." autocomplete="off" />
  <button id="send-btn">Send</button>
</div>

<script>
(() => {
  const chatWindow = document.getElementById('chat-window');
  const userInput = document.getElementById('user-input');
  const sendBtn = document.getElementById('send-btn');
  const botName = "BBTT";
  const userName = "User";

  // Letter list and base weights (ETAOIN order approx)
  const letters = "ETAOINSHRDLCUMWFGYPBVKJXQZ".split('');
  const baseWeights = [12.7,9.1,8.2,7.5,7.0,6.7,6.3,6.1,6.0,4.3,4.0,2.8,2.8,2.4,2.4,2.2,2.0,2.0,1.9,1.5,1.0,0.8,0.2,0.2,0.1,0.1];

  // Simple Markov Chain sample transitions
  const baseMarkovChain = {
    E: ['R', 'S', 'D', 'N', 'T'],
    T: ['H', 'O', 'E', 'A', 'I'],
    A: ['N', 'T', 'R', 'L', 'S'],
    O: ['N', 'R', 'U', 'F', 'D'],
    I: ['N', 'S', 'T', 'L', 'D'],
    N: ['G', 'D', 'T', 'E', 'S'],
    S: ['T', 'H', 'I', 'E', 'A'],
    H: ['E', 'I', 'A', 'O', 'U'],
    R: ['E', 'A', 'I', 'O', 'U'],
    D: ['E', 'I', 'A', 'O', 'U'],
    L: ['E', 'A', 'I', 'O', 'U']
  };

  // Learning data (temporary for session)
  let userWordLengths = new Map();
  let userLetterFreq = new Map();
  let userMarkov = new Map();

  // Initialize userMarkov map keys with empty arrays
  for(let l of letters) userMarkov.set(l, []);

  // Utility funcs
  function weightedRandom(choices, weights) {
    let sum = weights.reduce((a,b) => a+b, 0);
    let r = Math.random() * sum;
    let acc = 0;
    for(let i=0; i<choices.length; i++){
      acc += weights[i];
      if(r <= acc) return choices[i];
    }
    return choices[choices.length-1];
  }

  function markovNextLetter(current, customChain){
    current = current.toUpperCase();
    let chain = customChain || baseMarkovChain;
    if(chain[current]){
      const nextLetters = chain[current];
      return nextLetters[Math.floor(Math.random() * nextLetters.length)];
    }
    return weightedRandom(letters, baseWeights);
  }

  function numberToLetter(num){
    if(num >= 1 && num <= 26) return String.fromCharCode(num + 64);
    return weightedRandom(letters, baseWeights);
  }

  function textToNumbers(text){
    const nums = [];
    for(let ch of text.toUpperCase()){
      if(ch >= 'A' && ch <= 'Z') nums.push(ch.charCodeAt(0) - 64);
    }
    return nums;
  }

  function generateSimilarNumberSequence(inputNums){
    const newNums = [];
    for(let n of inputNums){
      const shift = [-1,0,1][Math.floor(Math.random()*3)];
      let newNum = ((n - 1 + shift + 26) % 26) + 1;
      newNums.push(newNum);
    }
    return newNums;
  }

  function generateWordFromNumbers(nums, customMarkov, customWeights){
    if(nums.length === 0) return generateWord(customMarkov, customWeights);
    let lettersArr = nums.map(numberToLetter);
    let word = [lettersArr[0]];
    for(let i=1; i<lettersArr.length; i++){
      let nextLetter = markovNextLetter(word[word.length -1], customMarkov);
      word.push(nextLetter);
    }
    return word.join('').toLowerCase();
  }

  function generateWord(customMarkov, customWeights){
    const length = Math.floor(Math.random()*4)+4; // 4-7 letters
    let nums = [];
    for(let i=0; i<length; i++){
      nums.push(Math.floor(Math.random()*26)+1);
    }
    return generateWordFromNumbers(nums, customMarkov, customWeights);
  }

  function generateSentenceWithGrammar(wordLengths, customMarkov, customWeights){
    let words = wordLengths.map(len => generateWordOfLength(len, customMarkov, customWeights));
    if(words.length === 0) return "";
    words[0] = capitalize(words[0]);
    return words.join(' ') + '.';
  }

  function generateWordOfLength(len, customMarkov, customWeights){
    let nums = [];
    for(let i=0; i<len; i++){
      nums.push(Math.floor(Math.random()*26)+1);
    }
    return generateWordFromNumbers(nums, customMarkov, customWeights);
  }

  function capitalize(str){
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  // Update learning from user input
  function learnFromInput(text){
    const words = text.toUpperCase().match(/\b[A-Z]+\b/g) || [];
    for(let w of words){
      userWordLengths.set(w.length, (userWordLengths.get(w.length) || 0) + 1);
      for(let i=0; i<w.length - 1; i++){
        const curr = w[i];
        const nxt = w[i+1];
        if(userMarkov.has(curr)) userMarkov.get(curr).push(nxt);
      }
      for(let ch of w){
        if(letters.includes(ch)) userLetterFreq.set(ch, (userLetterFreq.get(ch) || 0) +1);
      }
    }
  }

  function getCustomMarkov(){
    let customChain = {};
    for(let [k,v] of userMarkov.entries()){
      if(v.length > 0){
        // unique letters for next states
        customChain[k] = [...new Set(v)];
      } else {
        customChain[k] = baseMarkovChain[k] || letters;
      }
    }
    return customChain;
  }

  function getCustomWeights(){
    let total = 0;
    for(let v of userLetterFreq.values()) total += v;
    if(total === 0) return baseWeights;
    let weights = [];
    for(let l of letters){
      weights.push((userLetterFreq.get(l) || 0) / total);
    }
    // if all zero fallback
    if(weights.every(w => w === 0)) return baseWeights;
    return weights;
  }

  function pickWordLengths(count=5){
    let lengths = [...userWordLengths.keys()];
    if(lengths.length === 0){
      // fallback random lengths 3-7
      let arr = [];
      for(let i=0; i<count; i++) arr.push(Math.floor(Math.random()*5)+3);
      return arr;
    }
    // weighted choice
    let total = 0;
    let weights = [];
    for(let l of lengths){
      let val = userWordLengths.get(l);
      weights.push(val);
      total += val;
    }
    let chosen = [];
    for(let i=0; i<count; i++){
      let r = Math.random() * total;
      let acc = 0;
      for(let j=0; j<lengths.length; j++){
        acc += weights[j];
        if(r <= acc){
          chosen.push(lengths[j]);
          break;
        }
      }
    }
    return chosen;
  }

  // Add message to chat window
  function addMessage(text, isUser){
    const container = document.createElement('div');
    container.classList.add('message', isUser ? 'user-message' : 'bot-message');

    const nameElem = document.createElement('div');
    nameElem.classList.add('username', isUser ? 'user-name' : 'bot-name');
    nameElem.textContent = isUser ? userName : botName;
    container.appendChild(nameElem);

    const msgElem = document.createElement('div');
    msgElem.textContent = text;
    container.appendChild(msgElem);

    chatWindow.appendChild(container);
    chatWindow.scrollTop = chatWindow.scrollHeight;
  }

  // Typing effect for bot messages
  async function botTypingEffect(text){
    const container = document.createElement('div');
    container.classList.add('message', 'bot-message');

    const nameElem = document.createElement('div');
    nameElem.classList.add('username', 'bot-name');
    nameElem.textContent = botName;
    container.appendChild(nameElem);

    const msgElem = document.createElement('div');
    container.appendChild(msgElem);

    chatWindow.appendChild(container);
    chatWindow.scrollTop = chatWindow.scrollHeight;

    for(let i=0; i<=text.length; i++){
      msgElem.textContent = text.slice(0,i);
      chatWindow.scrollTop = chatWindow.scrollHeight;
      await new Promise(r => setTimeout(r, 25));
    }
  }

  async function botRespond(userText){
    learnFromInput(userText);
    const customMarkov = getCustomMarkov();
    const customWeights = getCustomWeights();

    let response = "";
    if(Math.random() < 0.5){
      // Use similar number sequence approach
      const userNums = textToNumbers(userText);
      const botNums = generateSimilarNumberSequence(userNums);
      response = generateWordFromNumbers(botNums, customMarkov, customWeights);
    } else {
      // Generate sentence with grammar
      const wordLengths = pickWordLengths(Math.floor(Math.random()*4)+4);
      response = generateSentenceWithGrammar(wordLengths, customMarkov, customWeights);
    }
    await botTypingEffect(response);
  }

  // Send handler
  async function onSend(){
    const text = userInput.value.trim();
    if(!text) return;
    addMessage(text, true);
    userInput.value = "";
    await botRespond(text);
  }

  // Handle enter key
  userInput.addEventListener('keydown', e => {
    if(e.key === 'Enter') {
      e.preventDefault();
      sendBtn.click();
    }
  });

  sendBtn.addEventListener('click', onSend);

  // Initial greeting
  addMessage("Hey! I'm BBTT, A confusing chatbot! Let's chat! try to decode my messages...", false);

})();
</script>
</body>
</html>
